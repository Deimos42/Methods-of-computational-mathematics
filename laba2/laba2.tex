\documentclass[13pt,a4paper]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage{misccorr}
\usepackage{graphicx}
\graphicspath{{pictures/}}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\usepackage{amsmath}
\begin{document}
	

\begin{center}
{\Large Методы вычислительной математики\\[10pt]
Лабораторная работа №2}\\[150pt]
\end{center}


\newpage	
\section{Раздел А}
Исходная матрица\\
$$
\left[
\begin{array}{ccccc}
0& 1& -1& 0& 1\\
1& 0& 1& 0& 0\\
1& 0& 1& 1& 0\\
0& 1& 1& 0& -1\\
0& 0& 1& 0& -1\\
0& 1& 1& 0& 1\\
\end{array}
\right]
$$
вектор правых частей  {\bf b}=[1,1,1,0,1,0]
\\

Значения норм столбов подматрицы и номер выбранного столбца на каждом шаге алгоритма:\\[10pt]
\begin{tabular}{|l|l|l|l|l|l|}
	\hline
	{номера шага/норма столбца} & {0 столб.} & {1 столб.} & {2 столб.}&{3 столб.}&{4 столб.}\\
	\hline
	{1 шаг} &{1.414213} & {1.732050}&{2.449489}&{1.0}&{2.0}\\
	\hline
	{2 шаг} &{-}&{1.683250} & {1.154700}&{0.912870}&{1.825741}\\
	\hline
	{3 шаг} & {-} & {-}&{1.095445}&{0.894427}&{1.516575}\\
	\hline
	{4 шаг} & {-} & {-}&{-}&{0.872278}&{1.025078}\\
	\hline
	{5 шаг} & {-} & {-}&{-}&{-}&{0.707106}\\
	\hline
\end{tabular}\\[20pt]
на 1 шаге выбираем {\bf 2} столбец\\
на 2 шаге выбираем {\bf 4} столбец\\
на 3 шаге выбираем {\bf 4}  столбец\\
на 4 шаге выбираем {\bf 4}  столбец\\
на 5 шаге выбираем {\bf 4}  столбец\\

{\bf Промежуточные матрицы с очередным занулённым столбцом:}\\
зануление 1-го столбца\\[5pt]
$$
\left[
\begin{array}{ccccc}
2.44949& 0.408248& 0.816497& 0.408248& -0.816497\\
0.0& 0.171548& 0.763299& -0.11835& 0.526599\\
0.0& 0.171548& 0.763299& 0.88165& 0.526599\\
0.0& 0.171548& -0.236701& -0.11835& -0.473401\\

0.0& 0.171548&  -0.236701& -0.11835&  -0.473401\\
0.0& 1.171548&  -0.236701& -0.11835& 1.526599\\
\end{array}
\right]
$$\\[5pt]

зануление 2-го столбца\\[5pt]
$$
\left[
\begin{array}{ccccc}
2.44949& -0.816497& 0.816497& 0.408248& 0.408248\\
0.0& -1.825742&  -0.365148& -0.182574& -0.730297\\
0.0& 0.0&  0.510683& 0.867272& -0.030341\\
0.0& 0.0&  -0.009604& -0.105425& 1.353041\\
0.0& 0.0&  -0.009604& -0.105425& 0.353041\\
0.0& 0.0&  -0.969029& -0.16003& 0.586278\\
\end{array}
\right]
$$\\[5pt]

зануление 3-го столбца\\[5pt]
$$
\left[
\begin{array}{ccccc}
2.44949& -0.816497& 0.408248& 0.408248& 0.816497\\
0.0& -1.825742&  -0.730297& -0.182574& -0.365148\\
0.0& 0.0&  1.516575& -0.197814& -0.395628\\
0.0& 0.0&  0.0& 0.826174& 0.78312\\
0.0& 0.0&  0.0& 0.137651& 0.197237\\
0.0& 0.0&  0.0& 0.243636& -0.625539\\
\end{array}
\right]
$$\\

зануление 4-го столбца\\[5pt]
$$
\left[
\begin{array}{ccccc}
2.44949& -0.816497& 0.408248& 0.816497& 0.408248\\
0.0& -1.825742&  -0.730297& -0.365148& -0.182574\\
0.0& 0.0&  1.516575& -0.395628& -0.197814\\
0.0& 0.0&  0.0& -1.021508& -0.510754\\
0.0& 0.0&  0.0& 0.0& -0.08468\\
0.0& 0.0&  0.0& 0.0& 0.707056\\
\end{array}
\right]
$$\\

зануление 5-го столбца\\[5pt]
$$
\left[
\begin{array}{ccccc}
2.44949& -0.816497& 0.408248& 0.816497& 0.408248\\
0.0& -1.825742&  -0.730297& -0.365148& -0.182574\\
0.0& 0.0&  1.516575& -0.395628& -0.197814\\
0.0& 0.0&  0.0& -1.021508& -0.510754\\
0.0& 0.0&  0.0& 0.0& 0.707107\\
0.0& 0.0&  0.0& 0.0& 0.0\\
\end{array}
\right]
$$\\
Преобразованная правая часть: [0.816497, -0.365148, 0.263752, -1.276885, 0.0, 1.224745]\\
Посчитанное решение X: [1.25, 0.5, -0.25, 0.0, -0.25]\\
норма невязки: 1.22\\



\section{Раздел Б}
Тестовый пример\\[10pt]
$$
\left[
\begin{array}{ccc}
12& -51& 4\\
6& 167& -68\\
-4& 24& -41\\
\end{array}
\right]
$$\\
b = [1.0,1.0,1.0]\\


Полученная система:\\
$$
\left[
\begin{array}{ccc}
176.255496& -71.169412& 1.668033\\
0.0& 35.438889& -2.180855\\
0.0& 0.0& -13.728129\\
\end{array}
\right]
$$\\
Преобразованная правая часть: [0.794301, -1.367707 ,-0.706018]\\
Посчитанное решение X: [0.051429, -0.010286, -0.035429]\\


\section{Раздел В}
Матричные разложения\\
Матрица Q:\\
$$
\left[
\begin{array}{cccccc}
-0.408248& -0.365148& 0.593442& -0.425628& 0.0& 0.408248\\
0.408248& -0.182574& -0.197814& -0.510754& -0.707107& 0.0\\
0.408248& -0.182574& -0.197814& -0.510754& 0.707107& 0.0\\
0.408248& 0.365148& 0.725319& -0.085126& 0.0& -0.408248\\
0.408248& 0.365148& 0.065938& 0.170251& 0.0& 0.816497\\
0.408248& -0.730297& 0.197814& 0.510754& 0.0& 0.0\\
\end{array}
\right]
$$\\

Матрица перестановок П:\\
$$
\left[
\begin{array}{ccccc}
0& 0& 0& 1& 0\\
0& 0& 1& 0& 0\\
1& 0& 0& 0& 0\\
0& 0& 0& 0& 1\\
0& 1& 0& 0& 0\\

\end{array}
\right]
$$\\

Проверка матричного равенства A*П=Q*R=\\
$$
\left[
\begin{array}{ccccc}
-1& 1& 1& 0& 0\\
1& 0& 0& 1& 0\\
1& 0& 0& 1& 1\\
1& -1& 1& 0& 0\\
1& -1& 0& 0& 0\\
1& 1& 1& 0& 0\\

\end{array}
\right]
$$\\


\section{Раздел Г}
SVD\\

Матрица U:\\
$$
\left[
\begin{array}{cccccc}
0.408351& 0.560035& 0.14497& 0.530652& 0.224356& 0.408248\\
-0.407347& 0.17837& -0.33921& -0.128368& 0.818969& 0.0\\
-0.465661& 0.230906& -0.567456& 0.457887& -0.44517& 0.0\\
-0.471068& 0.04996& 0.661023& 0.404375& 0.091987& -0.408248\\
-0.43971& -0.255038& 0.258027& -0.063139& -0.066184& 0.816497\\
-0.187692& 0.730539& 0.195921& -0.569881& -0.260643& 0.0\\
\end{array}
\right]
$$\\

Матрица V:\\
$$
\left[
\begin{array}{ccccc}
-0.308937& 0.195221& -0.575019& 0.372859& 0.629902\\
-0.088614&  0.639421&  0.635427&  0.413171&  0.093863\\
-0.842164&  0.178729&  0.040168& -0.486305& -0.143905\\
-0.164786&  0.11014&  -0.359888&  0.51811&  -0.750172\\
0.400388&  0.713411& -0.366677& -0.430506& -0.10463\\
\end{array}
\right]
$$\\

U*U.transpose():\\
$$
\left[
\begin{array}{cccccc}
1& 0& 0& 0& 0& 0\\
0& 1& 0& 0& 0& 0\\
0& 0& 1& 0& 0& 0\\
0& 0& 0& 1& 0& 0\\
0& 0& 0& 0& 1& 0\\
0& 0& 0& 0& 0& 1\\
\end{array}
\right]
$$\\

U.transpose()*U:\\
$$
\left[
\begin{array}{cccccc}
1& 0& 0& 0& 0& 0\\
0& 1& 0& 0& 0& 0\\
0& 0& 1& 0& 0& 0\\
0& 0& 0& 1& 0& 0\\
0& 0& 0& 0& 1& 0\\
0& 0& 0& 0& 0& 1\\
\end{array}
\right]
$$\\

V*V.transpose():\\
$$
\left[
\begin{array}{ccccc}
1& 0& 0& 0& 0\\
0& 1& 0& 0& 0\\
0& 0& 1& 0& 0\\
0& 0& 0& 1& 0\\
0& 0& 0& 0& 1\\
\end{array}
\right]
$$\\

V.transpose()*V:\\
$$
\left[
\begin{array}{ccccc}
1& 0& 0& 0& 0\\
0& 1& 0& 0& 0\\
0& 0& 1& 0& 0\\
0& 0& 0& 1& 0\\
0& 0& 0& 0& 1\\
\end{array}
\right]
$$\\

Матрица S(сигма) :\\
$$
\left[
\begin{array}{ccccc}
2.825848& 0& 0& 0& 0\\    
0&  2.096481& 0& 0& 0\\   
0&  0&  1.576756& 0& 0\\  
0&  0&  0&  0.883763& 0 \\
0&  0&  0&  0&  0.593425\\
0&  0&  0&   0&  0 \\
\end{array}
\right]
$$\\


Проверка матричного равенства U.transpose()*A*V=S\\
Проверочная матрица  U.transpose()*A*V:\\
$$
\left[
\begin{array}{ccccc}
2.825848& 0& 0& 0& 0\\    
0&  2.096481& 0& 0& 0\\   
0&  0&  1.576756& 0& 0\\  
0&  0&  0&  0.883763& 0 \\
0&  0&  0&  0&  0.593425\\
0&  0&  0&   0&  0 \\
\end{array}
\right]
$$\\
Она совпадает с матрицей S\\

Псевдообратная матрица A+ = V*(S+)*U.transpose():\\
$$
\left[
\begin{array}{cccccc}
0.416667&  1.0&        0.0&        0.083333& -0.166667& -0.5\\
0.5&          0.0&       0.0&        0.5&       0.0&        0.0\\
0.416667& 0.0&        0.0&       -0.083333&  0.166667&  0.5\\
0.0&       -1.0&        1.0&        0.0&       -0.0&       -0.0\\
-0.083333& 0.0&  0.0&  -0.416667& -0.166667&  0.5\\
\end{array}
\right]
$$\\

Матрица A*A+:\\
$$
\left[
\begin{array}{cccccc}
0.833333&  0.0&       0.0&    0.166667& -0.333333&  0.0\\
0.0&        1.0&        0.0&        0.0&        0.0&       0.0\\  
0.0&       0.0&        1.0&        0.0&       0.0&       0.0\\     
0.166667& 0.0&       0.0&        0.833333&  0.333333&  0.0\\     
-0.333333&  0.0&     0.0&        0.333333&  0.333333&  0.0\\      
0.0&   0.0&   0.0&  0.0&   0.0&   1.0\\
\end{array}
\right]
$$\\

Матрица (A+)*A:\\
$$
\left[
\begin{array}{ccccc}
1.0&  0.0&  0.0&  0.0& 0.0\\
0.0&  1.0&  0.0&  0.0& 0.0\\
0.0&  0.0&  1.0&  0.0& 0.0\\
0.0&  0.0&  0.0&  1.0& 0.0\\
0.0&  0.0&  0.0&  0.0& 1.0\\
\end{array}
\right]
$$\\


Решение с помощью SVD разложения: x=V*(S+)*c\\
c = U.transpose()*b\\
x = [1.25, 0.5, -0.25, 0, -0.25]\\


Решение с помощью псевдообратной матрицы: x = (A+)*b\\
x = [1.25, 0.5, -0.25, 0, -0.25]\\

\section{Исходный код}
\begin{verbatim}

1. QR

import time
import math
import numpy as np

# 10 вариант -> k = N mod 5 = 0

def sign(x):  # основная
    if x > 0:
        return 1
    elif(x < 0):
        return -1
    #else:
    #    return 0

def norm(X):   # основная
    m = 0
    for i in X:
        m += i*i  
    m = math.sqrt(m)
    return m
 
def make_householder2(a): # то же что и make_householder только без лишних выводов
    v = a / (a[0] + np.copysign(np.linalg.norm(a), a[0]))
    v[0] = 1
    H = np.eye(a.shape[0])
    H -= (2 / np.dot(v, v)) * np.dot(v[:, None], v[None, :])
    return H

def qr(A):
    print('----------- qr ----------------------------')
    m, n = A.shape
    Q = np.eye(m)
    print('Q: \n',Q)
    print('m: ',m,' n: ',n) #
    #A2 = A.transpose()  #
    PP = np.eye(A.shape[1],A.shape[1])
    for i in range(n - (m == n)):

        # выбор ведущего столбца в A
        A2 = A.transpose() #
        res = {}
        for k in range(i,len(A2)): # по столбцам A
            stolb = 0 
            for v in range(i,len(A2[k])): # по строкам A
                stolb += A2[k][v]**2
            stolb = math.sqrt(stolb) # вторая норма столбца
            #print('stolb: ',stolb,' k: ',k)
            res[k] = stolb
            print('норма ',k,'столбца матрицы = ',stolb)
        maxx = max(res.values())
        print('норма максимального столбца: ',maxx)  #    
        if maxx < 0.000001: # останавливаем выполнение разложения
            pass 
        else:  # переставляем i-ый столбец с maxx в матрице A          
            for l,h in res.items(): # получаем l - индекс 'максимального' столбца матрицы A
                if h == maxx:
                   break
            
            # формируем матрицу перестановок и умножаем матрицу A на неё
            P = np.eye(A.shape[1],A.shape[1])
            temp = np.copy(P[l])
            P[l] = P[i]
            P[i] = temp     
            PP = np.dot(PP,P) # сохраняем матрицу перестановок
            #print('A: \n',A.round(6))

            print('Выбираем',l,'столбец. Переставляем его с',i,'столбцом')
            A = np.dot(A,P)
            print('A: \n',A.round(6))
            

        H = np.eye(m)
        H[i:, i:] = make_householder2(A[i:, i])
        #print('H: \n',H) #
        #print('i: ',i) #
        Q = np.dot(Q, H)
        #print('Q: \n',Q.round(6))
        A = np.dot(H, A)
        print('A: \n',A.round(6))
    print('----------- qr ----------------------------')
    return Q, A, PP
 
 

# решение системы линейных уравнений после приведения матрицы к верхнетреугольному виду
def syst(R,c): # c - вектор правых частей, R - верхнетреугольная матрица
    X = [] 
    x = 0
    k = -1
    j = 1
    for st in reversed(R):
        x = c[k] 
        for i in range(j):
            # умножаем на bool(k != (-i-1)) чтобы не вычитался диагональный элемент
            if k < -1: # на первом шаге ничего не вычитаем
                #x = x - st[-i-1]*bool(k != (-i-1))*X[i]
                x = x - st[-i-1]*X[i]
        x = x / st[k]
        if k < -1:
            j += 1
        X.append(x)
        k -= 1
    X = X[::-1] # так как мы добавляли в конец то вектор x вышел перевернутым

    return X


# считаем норму невязки
def pogr(A,b,X):
    A_calcul = 0
    D = np.dot(A,X) 
    print('A*X: \n',D.round(6))
    print('b: \n',b)
    r = 0
    for v in range(len(D)):
        r += (D[v]-b[v])**2
    r = math.sqrt(r)
    
    return r

def test1():
    a = np.array(((
        (0,1,-1,0,1),
        (1,0,1,0,0),
        (1,0,1,1,0),
        (0,1,1,0,-1),
        (0,0,1,0,-1),
        (0,1,1,0,1),
    )))
    b = np.array((1.0,1.0,1.0,0.0,1.0,0.0))
    return a,b

# пример с нулевой нормой невязки
def test2():
    a = np.array(((
        (12, -51,   4),
        ( 6, 167, -68),
        (-4,  24, -41),
    )))
    b = np.array((1.0,1.0,1.0))
    return a,b

a,b = test1()
Q, R, PP = qr(a) # PP - матрица перестановок
print('Q:\n', Q.round(6))
print('R:\n', R.round(6))
print('матрица перестановок PP:\n', PP.round(6))

# проверка: если получается единичная матрица, то q - ортогональная матрица, значит qr разложение находится верно
#print('Q.transpose(): \n',Q.transpose().round(6)) 
#vv = np.dot(Q,Q.transpose()) #
#print('Q*Q.transpose: \n',vv.round(2)) #

#print('r: \n',np.dot(q.transpose(),a).round(2))
b2 = np.dot(Q.transpose(),b)
print('b2: \n',b2.round(6)) # находим изменённое b

m, n = a.shape # число строк и столбцов

# находим 'c' и 'r2' для решения системы уравнений
c = b2[:n]
R2 = R[:n]
print('c: \n',c.round(6))
print('R2: \n',R2.round(6))
# решаем систему уравнений
X = syst(R2,c) 
X = np.dot(PP,X)
print('Посчитанное решение X: ',X.round(6))
delta = pogr(a,b,X) # абсолютная погрешность
print('норма невязки: ',delta)

# проверяем верность равенства
print('проверяем верность равенства')
print('A*П: \n',np.dot(a,PP).round(6)) # PP - итоговая матрица перестановок П
print('Q*R: \n',np.dot(Q,R).round(6))






2. SVD

import numpy as np
import numpy.linalg as linalg #

# вычисляем матрицу S+
def MatrixSPlus(S):
    m = S.shape[0]
    n = S.shape[1]
    Splus = np.zeros((n,m))
    for i in range(n):  
        if S[i][i] < 10**(-10):
            Splus[i][i] = 0
        else:
            Splus[i][i] = 1/S[i][i]
    return Splus

# ищем ранг
def Rank(M):
    n = M.shape[0] # n = matrix.shape[1]
    r = 0
    while r < n and M[r][r]>10**(-10): 
        print(M[r][r])
        r += 1
    return r

# мой вариант(0)
def test1():
    A = np.array((
        (0.0, 1.0, -1.0, 0.0, 1.0),
        (1.0, 0.0, 1.0, 0.0, 0.0),
        (1.0, 0.0, 1.0, 1.0, 0.0),
        (0.0, 1.0, 1.0, 0.0, -1.0),
        (0.0, 0.0, 1.0, 0.0, -1.0),
        (0.0, 1.0, 1.0, 0.0, 1.0)
        ))
    b = np.array([1.0,1.0,1.0,0.0,1.0,0.0])
    return A,b

A,b = test1()
m,n = A.shape

# разложение для A
U,vector,VTrans = np.linalg.svd(A,True,True)
V = VTrans.transpose()
UTrans = U.transpose()

# строим диагональную матрицу S 
S = np.zeros((m,n))
for i in range(len(vector)):
    S[i][i] = vector[i]


print('Матрица U\n',U.round(6),'\n')
print('Матрица S\n',S.round(6),'\n')
print('Матрица V\n',V.round(6),'\n')

# проверка V и U на ортогональность
print('Матрица U*UTrans\n',np.dot(U,UTrans).round(6),'\n')
print('Матрица UTrans*U\n',np.dot(UTrans,U).round(6),'\n')

print('Матрица V*VTrans\n',np.dot(V,VTrans).round(6),'\n')
print('Матрица VTrans*V\n',np.dot(VTrans,V).round(6),'\n')

print('Матрица S\n',S.round(6),'\n')

# проверка правильности нахождения S
S_test = np.dot(A,V)
S_test = np.dot(UTrans,S_test)
print('Проверочная матрица S_test: \n',S_test.round(6),'\n')

SPlus = MatrixSPlus(S)
print('Матрица SPlus: \n',SPlus.round(6),'\n')

# вычисляем 'c'
rank = Rank(SPlus)
c = np.dot(UTrans,b) 
c[rank:] = 0
print('c: ',c)

# проверочное нахождение матрицы A
#A = np.dot(U,S)
#A = np.dot(A,VTrans)
#print('A: \n',A.round(6))

# находим матрицу A+
APlus = np.dot(SPlus,UTrans)
APlus = np.dot(V,APlus)
print('Псевдообратная матрица A+: \n',APlus.round(6),'\n')

##A = A.transpose()
AA = np.dot(A,APlus)
print(' Матрица A*A+: \n',AA.round(6),'\n')

AA2 = np.dot(APlus,A)
print('Матрица A+*A: \n',AA2.round(6),'\n')

# вычисляем y
y = np.dot(SPlus,c)
print('y: ',y)

# находим x
x = np.dot(V,y)
print('Решение с помощью SVD-разложения: ')
print('x: ',x.round(6))

x2 = np.dot(APlus,b)
print('Решение с помощью псвдообратной матрицы: ')
print('x: ',x2.round(6))


\end{verbatim}
\end{document}